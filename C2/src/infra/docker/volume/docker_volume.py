from dataclasses import dataclass, field
import docker
import logging

@dataclass
class DockerVolume:
    client: docker.DockerClient = field(default_factory=docker.from_env)
    logger: logging.Logger = field(default=logging.getLogger("DockerVolume"))
    _volume_name: str
    _driver: str = field(default="local")
    _driver_opts: dict = field(default_factory=dict)
    _labels: dict = field(default_factory=dict)
    _scope: str = field(default="local")
    _mount_opts: dict = field(default_factory=dict)
    _size_limit: str = field(default=None)
    _access_mode: str = field(default="rw")
    _encryption_opts: dict = field(default_factory=dict)
    _backup_opts: dict = field(default_factory=dict)
    _storage_plugin_opts: dict = field(default_factory=dict)
    _volume_id: str = field(init=False, default=None)

    def _set_volume_name(self, name:str) -> bool:
        set_name = False
        if not name:
            self.logger.error("Volume name is required.")
        else:
            self._volume_name = name
            self.logger.info("Volume name set to '{name}'.")  
            set_name = True
        return set_name
    
    def get_volume_name(self) -> str:
        return self._volume_name

    def _set_driver(self, driver: str) -> bool:
        set_driver = False
        valid_drivers = {'local', 'local-persist', 'nfs', 'tmpfs', 'convoy', 'rexray', 'cifs', 'glusterfs', 'ceph'}
        if driver not in valid_drivers:
            self.logger.error(f"Invalid volume driver. Valid drivers are: {valid_drivers}")
        else:
            self._driver = driver
            self.logger.info(f"Volume driver set to '{driver}'.")
            set_driver = True
        return set_driver
    
    def get_driver(self) -> str:
        return self._driver

    def _set_driver_opts(self, driver_opts: dict) -> bool:
        set_driver_opts = False
        if not isinstance(driver_opts, dict):
            self.logger.error("Driver options must be a dictionary.")
        else:
            self._driver_opts = driver_opts
            self.logger.info("Volume driver options set.")
            set_driver_opts = True
        return set_driver_opts

    def get_driver_opts(self) -> dict:
        return self._driver_opts

    def _set_labels(self, labels: dict) -> bool:
        set_labels = False
        if not isinstance(labels, dict):
            self.logger.error("Labels must be a dictionary.")
        else:
            self._labels = labels
            self.logger.info("Volume labels set.")
            set_labels = True
        return set_labels
    
    def get_labels(self) -> dict:
        return self._labels
    
    def _set_scope(self, scope: str) -> bool:
        set_scope = False
        valid_scopes = {'local', 'global'}
        if scope not in valid_scopes:
            self.logger.error(f"Invalid scope. Valid scopes are: {valid_scopes}")
        else:
            self._scope = scope
            self.logger.info(f"Scope set to '{scope}'.")
            set_scope = True
        return set_scope
    
    def get_scope(self) -> str:
        return self._scope
    
    def _set_size_limit(self, size_limit: str) -> bool:
        set_size_limit = False
        # Add any specific validation for size_limit if needed
        self._size_limit = size_limit
        self.logger.info(f"Size limit set to '{size_limit}'.")
        set_size_limit = True
        return set_size_limit

    def get_size_limit(self) -> str:
        return self._size_limit

    def _set_access_mode(self, access_mode: str) -> bool:
        set_access_mode = False
        valid_modes = {'rw', 'ro'}
        if access_mode not in valid_modes:
            self.logger.error(f"Invalid access mode. Valid modes are: {valid_modes}")
        else:
            self._access_mode = access_mode
            self.logger.info(f"Access mode set to '{access_mode}'.")
            set_access_mode = True
        return set_access_mode

    def get_access_mode(self) -> str:
        return self._access_mode

    def _set_encryption_opts(self, encryption_opts: dict) -> bool:
        set_encryption_opts = False
        if not isinstance(encryption_opts, dict):
            self.logger.error("Encryption options must be a dictionary.")
        else:
            self._encryption_opts = encryption_opts
            self.logger.info("Encryption options set.")
            set_encryption_opts = True
        return set_encryption_opts

    def get_encryption_opts(self) -> dict:
        return self._encryption_opts

    def _set_backup_opts(self, backup_opts: dict) -> bool:
        set_backup_opts = False
        if not isinstance(backup_opts, dict):
            self.logger.error("Backup options must be a dictionary.")
        else:
            self._backup_opts = backup_opts
            self.logger.info("Backup options set.")
            set_backup_opts = True
        return set_backup_opts

    def get_backup_opts(self) -> dict:
        return self._backup_opts

    def _set_storage_plugin_opts(self, storage_plugin_opts: dict) -> bool:
        set_storage_plugin_opts = False
        if not isinstance(storage_plugin_opts, dict):
            self.logger.error("Storage plugin options must be a dictionary.")
        else:
            self._storage_plugin_opts = storage_plugin_opts
            self.logger.info("Storage plugin options set.")
            set_storage_plugin_opts = True
        return set_storage_plugin_opts
    
    def get_storage_plugin_opts(self) -> dict:
        return self._storage_plugin_opts
    
    def create(self):
        # Implement the logic to create the Docker volume using the Docker API
        # This method should use the configured attributes to create the volume
        try:
            self.logger.info(f"Creating volume '{self._volume_name}'...")
            volume = self.client.volumes.create(
                name=self._volume_name, 
                driver=self._driver, 
                driver_opts=self._driver_opts, 
                labels=self._labels
                # Include other options as needed
            )
            self._volume_id = volume.id
            self.logger.info(f"Volume '{self._volume_name}' created.")
            return True
        except docker.errors.APIError as e:
            self.logger.error(f"API error: {e}")
            return False